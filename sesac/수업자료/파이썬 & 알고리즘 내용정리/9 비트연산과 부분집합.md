# 비트 연산

<aside>
💡 비트 연산이란?

</aside>

> 비트 연산을 다루기 전에, 이진법에 관한 이야기를 먼저 하겠습니다.
> 

`이진법`은 0️⃣ 과 1️⃣로 표현하는 숫자 체계입니다.

| 십진수 | 이진수 |
| --- | --- |
| 0 | 0 |
| 1 | 1 |
| 2 | 10 |
| 3 | 11 |
| 4 | 100 |
| 5 | 101 |
| 6 | 110 |
| 7 | 111 |
| 8 | 1000 |

십진수를 이진수로 변환하는 과정에서 이진수의 각 자리수는 2의 거듭제곱으로 계산됩니다.

ex) 7 = 2**²** + 2**¹** + ****2**⁰** ⇒ `111₂`

## 비트연산

### 비트 연산자

| 연산자 종류 | 효과 | 수식 |
| --- | --- | --- |
| & | and | a & b |
| | | or | a | b |
| << | 왼쪽 shift | a << n  |
| >> | 오른쪽 shift | a >> n  |
| ^ | xor | a ^ b |

### `& (and)`

> 비교하고자 하는 비트가 둘다 1인 경우만 1로, 하나라도 0이라면 0으로 계산합니다.
> 

<aside>
💡 비트연산은 십진수를 대상으로 하더라도, 이진수를 위아래로 비교한다고 생각합니다.

</aside>

```python
# 예시
print(6 & 3)  # 결과는 2입니다.

# 1 1 0 => 6
# 0 1 1 => 3  => 자리수가 모자란 경우 왼쪽에 0이 채워진다고 생각합니다.
# ----&----- 
# 0 1 0 => 2
```

### `| (or)`

> 비교하고자 하는 비트 중 단 하나라도 1이면 1로 계산합니다. 둘다 0이면 0이겠죠?
> 

```python
print(6 | 3) # 결과는 7입니다.

# 1 1 0 => 6
# 0 1 1 => 3
# ----|----- 
# 1 1 1 => 7
```

### `<< (왼쪽 shift)`

> 비트를 왼쪽으로 n칸 이동시킵니다. 새로 생긴 부분은 `0`으로 계산합니다.
> 

```python
# 왼쪽 한 칸 & 두 칸 이동
print(7 << 1)  # 14가 답이 됩니다.
print(7 << 2)  # 28이 답이 됩니다.

# 1 1 1
# <<
# 1 1 1 0 => 14
# <<
# 1 1 1 0 0 => 28
```

따라서 비트를 1칸 왼쪽으로 이동시킬때마다, 십진수 기준으로는 `2배씩` 늘어납니다.

### `>> (오른쪽 shift)`

> 비트를 오른쪽으로 n칸 이동시킵니다. 오른쪽으로 없어진 부분은 `삭제`됩니다.
> 

```python
# 오른쪽으로 이동
print(7 >> 1)  # 3이 답이 됩니다. (7을 2로 나눈 몫)
print(27 >> 2) # 6이 답이 됩니다. (27을 4로 나눈 몫) => 2의 2승으로 나눈 몫
print(415 >> 4) # 25가 답이 됩니다. (415를 16으로 나눈 몫)
```

### `^ (xor)` (exclusive or, 배타적 논리쌍)

> 비교하고자 하는 비트가 서로 `달라야지만` 1이고, 같으면 0으로 계산합니다.
> 

```python
print(6 ^ 3)  # 결과는 5입니다.

# 1 1 0 => 6
# 0 1 1 => 3  => 자리수가 모자란 경우 왼쪽에 0이 채워진다고 생각합니다.
# ----^----- 
# 1 0 1 => 5
```

## 부분집합 구하기

<aside>
💡 비트 shift를 활용해 부분집합 코드를 구현할 수 있습니다.

</aside>

```python
# 비트를 활용한 부분집합 구하기
letters = ['a', 'b', 'c']

for i in range(1 << len(letters)):  # 총 2³, 8개의 경우의 수 체크
    selected = []
    for j in range(len(letters)): # 각각 비트를 한칸씩 옮기며 대조
        if i & (1 << j):  # 1칸씩 왼쪽으로 옮겨가며 총 3칸을 대조해본다.
            selected.append(letters[j]) # 대조 결과가 성공이라면 selected에 append!

    print(selected)

# []                | => (i = 0) => 0 0 0 => 공집합
# ['a']             | => (i = 1) => 0 0 1 => (j = 0)에서 걸려 'a'가 뽑힘
# ['b']             | => (i = 2) => 0 1 0
# ['a', 'b']        | => (i = 3) => 0 1 1
# ['c']             | => (i = 4) => 1 0 0 => (j = 2)에서 걸려 'c'가 뽑힘
# ['a', 'c']        | => (i = 5) => 1 0 1
# ['b', 'c']        | => (i = 6) => 1 1 0
# ['a', 'b', 'c']   | => (i = 7) => 1 1 1
```