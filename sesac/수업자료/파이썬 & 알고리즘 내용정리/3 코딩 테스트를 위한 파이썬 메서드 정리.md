# 메서드 정리

## 리스트

<aside>
💡 리스트의 메서드를 공부합니다.

</aside>

리스트는 기본적으로 대괄호로 표현하며, 인덱스 값을 활용해 O(1)시간 안에 접근할 수 있습니다.

없는 인덱스를 지정하면, IndexError가 발생합니다.

```python
nums = [3, 5, 1, 4, 2]
print(nums[0]) # 3
nums[1] = 7
print(nums) # [3, 7, 1, 4, 2]
nums[8] = 9 # IndexError: list assignment index out of range
```

```python
# 리스트 안에는 다양한 자료형이 들어갈 수 있고, 길이는 가변적입니다.
my_list = ['hi', True, [1, 2, 3], {'name':'tom'}, {7, 6}, (4, 5, 8)]
```

### 1️⃣ .append()

> 리스트의 맨 뒤에 요소를 `1개` 추가합니다.
> 

```python
nums = [3, 5, 1, 4, 2]
nums.append(6) # 원소 추가
print(nums) # [3, 5, 1, 4, 2, 6]
```

### 2️⃣ .pop(index)

> 리스트에서 인덱스 위치에 해당하는 원소를 추출한 후 반환합니다.
> 

```python
nums = [3, 5, 1, 4, 2]
print(nums.pop(3)) # 3번째 인덱스에서 뽑았으니 4를 반환하고 남은 배열은 [3, 5, 1, 2]
print(nums.pop()) # 지정하지 않는 경우 맨 뒤에서 뽑습니다 => 2를 반환하고 남은 배열은 [3, 5, 1]
print(nums.pop(0)) # 맨 앞에서 뽑습니다 => 3을 반환하고 남은 배열은 [5, 1]
```

### 3️⃣ .sort()

> 작은 수부터 차례로 정렬합니다. key 옵션을 통해 기준을 선택할 수 있습니다.
> 

```python
nums = [3, 5, 1, 4, 2]
nums.sort()
print(nums) # [1, 2, 3, 4, 5] => 원본 자체를 정렬합니다.

# 만약 역순으로 정렬하고 싶은 경우? key 옵션과 익명함수 lambda를 활용합니다.
# nums.sort(key=lambda x: -x)
```

- sorted() 함수와의 차이

```python
nums = [3, 5, 1, 4, 2]
new_nums = sorted(nums) # 정렬한 새로운 리스트를 만듭니다.
print(nums, new_nums) # [3, 5, 1, 4, 2] [1, 2, 3, 4, 5]
```

### 4️⃣ .reverse()

> 주어진 리스트를 반대로 뒤집습니다. 정렬과는 관계가 없습니다.
> 

```python
nums = [3, 5, 1, 4, 2]
nums.reverse()
print(nums) # [2, 4, 1, 5, 3]
```

- reversed() 함수와의 차이 → reversed object를 만듭니다.
    - reversed는 list()로 한번 더 감싸줘야 활용이 가능합니다.

```python
nums = [3, 5, 1, 4, 2]
new_nums = reversed(nums)
print(nums, new_nums) # [3, 5, 1, 4, 2] <list_reverseiterator object at 0x000001E76A22F400>
print(list(new_nums)) # [2, 4, 1, 5, 3]

```

### 5️⃣ .insert(인덱스위치, 값)

> 특정 인덱스 위치에 두번 째 인자로 받는 값을 추가합니다.
> 

```python
nums = [3, 5, 1, 4, 2]
nums.insert(1, 9)
print(nums) # [3, 9, 5, 1, 4, 2]
```

### 6️⃣ .extend(반복 가능한 객체)

> 리스트의 끝에 여러개의 값을 추가할 수 있습니다.
> 

list는 `예약어` 이므로 변수명으로 짓지 않게 주의합니다.

```python
# 만약 [3, 5, 1, 4, 2]에 7, 6, 8 을 합치고 싶은 경우?
nums = [3, 5, 1, 4, 2]
nums.extend([7, 6, 8])
print(nums) # [3, 5, 1, 4, 2, 7, 6, 8]
```

```python
# 하나만 합칠 경우
nums = [3, 5, 1, 4, 2]
nums.extend([7])
print(nums) # [3, 5, 1, 4, 2, 7]

# 스트링 같은 반복 가능한 객체를 그자체로 넣어버린 경우
letters = ['p', 'y', 't', 'h', 'o', 'n']
letters.extend('algorithm')
print(letters)
# ['p', 'y', 't', 'h', 'o', 'n', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm']
```

> 더하기 + 연산으로도 리스트를 합칠 수 있습니다. (앞 뒤 덧셈 모두 가능)
> 

```python
nums = [3, 5, 1, 4, 2] + [7, 6, 8]
print(nums) # [3, 5, 1, 4, 2, 7, 6, 8]
```

### 7️⃣ count(n)

> n의 갯수를 반환합니다.
> 

```python
nums = [3, 5, 1, 4, 2, 5]
print(nums.count(5)) # 2
```

### 8️⃣ index(n)

> n의 인덱스값을 반환합니다. 만약 찾지 못하면 에러가 발생합니다.
> 

```python
nums = [3, 5, 1, 4, 2]
print(nums.index(1)) # 2
print(nums.index(9)) # ValueError: 9 is not in list
```

---

<aside>
💡 리스트의 슬라이싱 탐구

</aside>

> 리스트 슬라이싱을 활용하여 리스트의 일부를 복사하거나 도려내거나 삽입할 수 있습니다.
> 

`1` 도려내는 경우 `[ n : m ]` ⇒  [ n 포함 ~ m 미만 ]

```python
nums = [3, 5, 1, 4, 2]
sliced_nums = nums[2:4] # 인덱스 2 ~ 4 중 마지막 4를 제외한데까지 도려냄.
print(nums, sliced_nums) # [3, 5, 1, 4, 2] [1, 4]

# 왼쪽을 지정하지 않은 경우 0이라고 간주하고, 오른쪽을 지정하지 않은 경우 끝까지라고 인식합니다.
print(nums[:2]) # [3, 5]
print(nums[1:]) # [5, 1, 4, 2]

# 슬라이싱은 특이하게 인덱스 값을 초과하더라도 에러가 나지 않습니다.
print(nums[2:100]) # [1, 4, 2]
```

`2` 해당 특성을 이용하여  ‘전체’를 도려내면 리스트를 카피할 수 있습니다. (얕은 복사)

```python
nums = [3, 5, 1, 4, 2]
nums2 = nums  # 같은 객체를 가리키게 되어 동일한 id 값을 같습니다.

copied_nums = nums[:]
print(copied_nums) # [3, 5, 1, 4, 2]
reversed_nums = nums[::-1]
print(reversed_nums) # [2, 4, 1, 5, 3]

# 얕은 복사를 사용하는 경우 id 값이 분리되므로 변경 시, 서로에게 영향을 주지 않습니다.
nums[0] = 100
print(nums, copied_nums) # [100, 5, 1, 4, 2] [3, 5, 1, 4, 2]
print(nums2) # [100, 5, 1, 4, 2] => 같은 객체이므로 nums[0] = 100을 통해 동일하게 변화합니다.
```

`3` 특정 부분을 슬라이싱 하여 그 자리에 대신 삽입할 수 있습니다.

```python
nums = [3, 5, 1, 4, 2]
nums[1:2] = [9, 10, 11]
print(nums) # [3, 9, 10, 11, 1, 4, 2]
```

이를 응용하면, 특정 부분을 깔끔하게 도려내는 것도 가능합니다.

```python
nums = [3, 5, 1, 4, 2]
nums[2:4] = []
print(nums) # [3, 5, 2]
```

---

## 딕셔너리

딕셔너리의 구조 ⇒  `{ key : value }`

key 값으로 접근해 value 값을 얻을 수 있습니다. 해쉬 자료구조로써 탐색이 O(1)로 매우 빠릅니다.

없는 key 값에 접근하려 하는 경우 에러가 발생합니다.

```python
user_info = {'name': 'alex'}
print(user_info['name']) # alex
print(user_info['age']) # KeyError: 'age'
```

```python
# 기본적인 추가와 수정
user_info = dict()
user_info['name'] = 'alex'
print(user_info) # {'name': 'alex'}
```

### 1️⃣ .get( 키 값, 없으면 반환할 값 지정)

> get 메서드를 활용해 key값에 접근, value값을 얻을 수 있습니다. 직접 접근과 다르게 없어도 에러가 발생하지 않으며, 만약 찾지 못하는 경우 반환할 기본 값을 지정할 수 있습니다.
기본 값을 지정하지 않으면 찾지 못하는 경우 `None`을 반환합니다.
> 

```python
user_info = {'name': 'alex'}
print(user_info.get('name')) # alex
print(user_info.get('age', '발견하지 못함')) # 발견하지 못함
```

### 2️⃣ .update()

> key, value 쌍을 추가합니다. 만약 동일한 키값이 있다면 덮어씌워집니다.
> 

```python
dict1 = {'name': 'alex', 'address': 'Seoul'}
dict2 = {'name': 'jane', 'age': 7, 'license': True}
dict1.update(dict2)
print(dict1) # {'name': 'jane', 'address': 'Seoul', 'age': 7, 'license': True}
```

### 3️⃣ .pop(key, 없으면 반환할 값)

> key가 존재하면 제거하고 value값을 반환합니다. 기본 값을 지정하는 경우 찾지 못하면 반환할 값을 설정할 수 있습니다.
> 

```python
dict1 = {'name': 'alex', 'address': 'Seoul'}
print(dict1.pop('name')) # alex
print(dict1) # {'address': 'Seoul'}

# del의 경우 삭제하고자 하는 키값이 없는 경우 에러가 발생합니다.
dict2 = {'name': 'jane', 'age': 7, 'license': True}
del dict2['name']
print(dict2) # {'age': 7, 'license': True}
del dict2['address'] # KeyError: 'address'
```

### 4️⃣ keys(), values(), items()

> key, value들의 모임을 생성합니다.
> 

```python
dict1 = {'name': 'alex', 'address': 'Seoul'}

for key in dict1.keys():  # key들 모임
    print(key)
# name
# address

for value in dict1.values(): # value들 모임
    print(value)

# alex
# Seoul

for key, value in dict1.items(): # 두개 다의 모임
    print(key, value)

# name alex
# address Seoul
```

---

## 스트링

### 1️⃣ .replace(old, new, 갯수)

> 변경하고자 하는 문자를 지정한 문자로 변경 후 반환, 갯수 지정 시 몇개까지만 바꿀건지 지정 가능
> 

```python
word = 'hello world'
new_word = word.replace('o', 'k')
print(word) # hello world => 원본은 변화하지 않습니다.
print(new_word) # hellk wkrld
```

### 2️⃣ .split()

> 문자열을 특정 기준으로 나누어 리스트로 반환, 지정하지 않을 시 공백을 기준으로 반환
> 

```python
email = 'alexalgoedu@gmail.com'
split_email = email.split('@')
print(email) # alexalgoedu@gmail.com
print(split_email) # ['alexalgoedu', 'gmail.com']
```

```python
nums = '1 2 3'
print(nums.split()) # ['1', '2', '3']
```

### 3️⃣ .join()

> 반복 가능한(iterable)객체를 특정 기준으로 이어붙인 문자열을 반환
> 

```python
# 실제로 스트링 그 자체거나?
word = 'python'
print('-'.join(word)) # p-y-t-h-o-n

# 리스트의 원소 자체가 스트링이어야지 됨
word = ['p', 'y', 't', 'h', 'o', 'n']
print('-'.join(word)) # p-y-t-h-o-n
```

### 4️⃣ .find() , .index()

> 문자열 탐색 및 탐색 결과의 맨 첫번째 인덱스 반환
> 

```python
word = 'python'
print(word.find('t')) # 2 => 존재하지 않으면 -1 반환

word = 'python'
print(word.index('t')) # 2 => 존재하지 않으면 오류
```

---

## 셋 (SET)

### 1️⃣ .add()

> 셋 자료구조에 원소를 추가합니다.
> 

```python
cities = {'Seoul', 'New York'}
cities.add('Tokyo')
print(cities) # {'Seoul', 'New York', 'Tokyo'}

# 리스트 등과 같은 unhashable type은 추가할 수 없습니다.
cities.add([1]) # TypeError: unhashable type: 'list'
```

### 2️⃣ .remove, .discard

> 원소 삭제
> 

```python
cities = {'Seoul', 'New York'}
cities.remove('Seoul') # 없는 경우 KeyError 발생
cities.discard('Paris') # 없어도 에러가 발생하지 않음
print(cities) # {'New York'}
```

### 3️⃣ .update(iterable)

> 여러개 추가, set은 자료의 순서를 보장하지 않으므로 print 찍을때마다 다르게 나올 수 있음.
> 

```python
cities = {'Seoul', 'New York'}
cities.update(['Paris', 'London'])
print(cities) # {'London', 'Paris', 'Seoul', 'New York'} 
```

### 4️⃣ .pop()

> 랜덤 원소 1개 제거
> 

```python
cities = {'Seoul', 'New York'}
cities.pop()
print(cities)
```

## 기타 유용한 내장함수들

### 1️⃣ range(start, end, step)

> start 포함, end 미만까지의 정수를 step 단위만큼 차례로 생성합니다.
> 

```python
for i in range(4): # 지정하지 않는 경우 0부터 시작
    print(i, end=' ')  
print()

# 0 1 2 3

for j in range(7, 1, -1):  # -를 통해 역순으로 뽑을 수 있음
    print(j, end=' ')
print()

# 7 6 5 4 3 2

for k in range(1, 7, 2):  # 2칸씩 띄고 가능
    print(k, end=' ')
```

```python
# 리스트화
print(list(range(3, 7))) # [3, 4, 5, 6]
```

### 2️⃣ zip

> 세로로 자료구조를 찝어서 한 열씩 튜플로 만듭니다. 추후 응용해서 2차원 배열 전치도 가능합니다.
> 

```python
# 세로로 찝은 결과를 튜플로 만드는데 까지가 zip 객체를 생성 => 리스트화 해줍니다.
a = [1, 2, 3]
b = [4, 5, 6]
print(list(zip(a, b))) # [(1, 4), (2, 5), (3, 6)]

# 더 여러개도 찝을 수 있습니다.
a = [1, 2, 3]
b = [4, 5, 6]
c = [7, 8, 9]
print(list(zip(a, b, c))) # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]

# 만약 길이가 안맞으면 최소 값에 맞춰줍니다.
a = [1, 2, 3, 4]
b = [5, 6]
c = [7, 8, 9, 10]
print(list(zip(a, b, c))) # [(1, 5, 7), (2, 6, 8)]

# 이런것도 가능합니다. 레인지와 리스트를 찝어서 딕셔너리 형태로 제작
print(dict(zip(range(3), [0]*3))) # {0: 0, 1: 0, 2: 0}
```

### 3️⃣ enumerate

> 반복문에서 인덱스 값까지 같이 뽑을 수 있습니다.
> 

```python
nums = [2, 4, 6]

for idx, num in enumerate(nums):
    print(idx, num)

# 0 2
# 1 4
# 2 6
```

### 4️⃣ max, min, sum, len

> 최대, 최소, 합계, 길이를 쉽게 구할 수 있습니다.
> 

```python
nums = [2, 4, 6, 1, 7, 8]
print(max(nums), min(nums), sum(nums), len(nums)) # 8 1 28 6
```