# 2차원 리스트 탐구

<aside>
💡 2차원 리스트는 행렬 표현에 활용합니다.

</aside>

```python
# 2차원 리스트는 원소로 1차원 리스트를 가집니다.
matrix = [[3, 7, 9], [4, 2, 6], [8, 1, 5]]

# 줄바꿈을 통해 더욱 행렬처럼 만들 수 있습니다.
matrix = [[3, 7, 9],
		      [4, 2, 6],
	    	  [8, 1, 5]]
```

가로축을 **행(row)**, 세로축을 **열(column)**이라고 생각하면 그림으로는 다음과 같습니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1578ced4-e8d1-4fd8-9b4a-b2369332e6af/Untitled.png)

```python
# 만약 8에 접근하고 싶다면? 큰 행렬 기준으로는 행이 2이고, 열이 0번째 인덱스 이므로?
matrix = [[3, 7, 9],
		      [4, 2, 6],
	    	  [8, 1, 5]]

print(matrix[2][0]) # 8
```

## 순회 & 전치

> 2차원 리스트의 순회
>

: 2차원 리스트를 모두 한 번씩 방문하는 완전탐색 문제에서 자주 활용하게 됩니다.

순회 방식에 따라 행, 열 우선순회로 나뉘며 2중 포문을 이용해야 합니다.

1️⃣ 행 우선 순회

```python
matrix = [[3, 7, 9],
		      [4, 2, 6],
	    	  [8, 1, 5]]

trails = []  # 순회 궤적 담아줄 리스트

for r in range(3):
    for c in range(3):  # r 이 하나 고정된 상태에서 각각
        trails.append(matrix[r][c])

print(trails)  # [3, 7, 9, 4, 2, 6, 8, 1, 5]
```

💡 행으로 순회 하긴 하는데 열은 역순으로?

```python
# 행으로 순회 하긴 하는데 열은 역순으로?
matrix = [[3, 7, 9],
		      [4, 2, 6],
	    	  [8, 1, 5]]

trails = []  # 순회 궤적 담아줄 리스트

for r in range(3):
    for c in range(2, -1, -1):  # 역순인데, 새끼 리스트의 길이 - 1 시작!
        trails.append(matrix[r][c])

print(trails) # [9, 7, 3, 6, 2, 4, 5, 1, 8]
```

💡 행 우선순회긴 한데, 지그재그로?

```python
matrix = [[3, 7, 9],
		      [4, 2, 6],
	    	  [8, 1, 5]]

trails = []  # 순회 궤적 담아줄 리스트

for r in range(3):
    if r % 2 == 0:
        for c in range(3):
            trails.append(matrix[r][c])
    elif r % 2 == 1:
        for c in range(2, -1, -1):
            trails.append(matrix[r][c])

print(trails) # [3, 7, 9, 6, 2, 4, 8, 1, 5]
```

2️⃣ 열 우선 순회

```python
matrix = [[3, 7, 9],
		      [4, 2, 6],
	    	  [8, 1, 5]]

trails = []

for r in range(3):
    for c in range(3):
        trails.append(matrix[c][r])  # 여기가 바뀝니다.

print(trails)  # [3, 4, 8, 7, 2, 1, 9, 6, 5]

```

---

3️⃣ 전치(Transpose)

```python
matrix = [[3, 7, 9],
		      [4, 2, 6],
	    	  [8, 1, 5]]

for r in range(3):
    for c in range(3):
        if r > c: # r < c로 해도 됩니다.
            matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]

for i in range(3):
    print(matrix[i])

# [3, 4, 8]
# [7, 2, 1]
# [9, 6, 5]
```

```python
# zip을 활용한 전치하기 => 원소가 튜플이 됩니다.
zipped_matrix = list(zip(*matrix))
print(zipped_matrix) # [(3, 4, 8), (7, 2, 1), (9, 6, 5)]

# 전치 완료 후, 원소를 리스트로 활용하고 싶을 때
transposed_matrix = list(map(list, zip(*matrix)))
print(transposed_matrix)
# [[3, 4, 8], [7, 2, 1], [9, 6, 5]]
```

## 회전**↪️**

다음과 같은 3 x 3 이차원 리스트가 있습니다.

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```

알고리즘 문제에서 이차원 리스트를 회전시켜야 하는 경우가 많습니다.

먼저 인덱스를 조작하여 이차원 리스트의 회전을 구현할 수 있습니다.

> 90도 회전
>

오른쪽으로 90도를 회전시킨 이차원 리스트를 얻는 방법은 아래와 같습니다.

```python
n = 3
rotated_matrix = [[0] * n for _ in range(n)]  # 초기화

for i in range(n):
    for j in range(n):
        rotated_matrix[i][j] = matrix[n-j-1][i]
# rotated_matrix 결과

[
    [7, 4, 1],
    [8, 5, 2],
    [9, 6, 3]
]
```

회전 시킨 이차원 리스트를 담을 rotated_matrix 변수를 선언하고 모든 원소를 0으로 초기화합니다.

이중 for문을 순회하며, matrix의 (n-j-1)행, i열에 담긴 원소를 rotated_matrix의 i행, j열에 넣습니다.

여기서 1을 빼는 이유는 마지막 행의 번호는 n이 아니라 n-1이기 때문입니다.

반대로 왼쪽으로 90도 회전시킨 이차원 리스트는 어떻게 얻을까요?

```python
n = 3
rotated_matrix = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        rotated_matrix[i][j] = matrix[j][n-i-1]
# rotated_matrix 결과

[
    [3, 6, 9],
    [2, 5, 8],
    [1, 4, 7]
]
```

전체적인 코드는 거의 비슷하지만, matrix의 인덱스 조작을 어떻게 하느냐만 달라집니다.

> 내장 함수 zip을 이용한 90도 회전
>

내장 함수 zip과 리스트 슬라이싱을 활용하면 앞서 했던 90도 회전을 간단하게 구현할 수 있습니다.

기본적인 구조는 zip을 이용한 전치와 비슷합니다. 리스트 슬라이싱이 추가로 붙는 형태입니다.

먼저 오른쪽으로 90도 회전하는 것 부터 알아보겠습니다.

```python
rotated_matrix = list(zip(*matrix[::-1]))
# rotated_matrix 결과

[
    (7, 4, 1),
    (8, 5, 2),
    (9, 6, 3)
]
```

다음은 왼쪽으로 90도 회전하는 것에 대해 알아보겠습니다.

```python
rotated_matrix = list(zip(*matrix))[::-1]
# rotated_matrix 결과

[
    (3, 6, 9),
    (2, 5, 8),
    (1, 4, 7)
]
```

리스트 슬라이싱 `[::-1]`의 의미는 리스트 내부 원소의 순서를 거꾸로(reverse) 뒤집는 것입니다.

`[::-1]`이 matrix 옆에 있는지, 바깥에 있는지 그 위치에 따라 회전의 방향을 결정할 수 있습니다.

## 2차원 리스트의 활용

<aside>
💡 인접 행렬 구하기

</aside>

> 그래프의 노드들 간 간선이 이어져 있음을 구조화 할 수 있습니다.
>

0 ~ 3번 위치에서 서로가 서로에게 길이 뚫려 있다는 아래와 같은 그림은 2차원 리스트로 어떻게 표현할까요? ⇒ 인접 행렬(adjacent matrix)을 활용합니다.

![Untitled](https://useful-pantry-930.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff156dbcf-dfcc-43e2-8390-4af1f99fd1e0%2FUntitled.png?table=block&id=68dd9fc6-6919-4f02-817c-9da55c894be2&spaceId=2c73f946-8332-4a01-81d0-e72428bf9af8&width=1750&userId=&cache=v2)

```python
ways = [[0, 1, 1, 0],  # 0번 위치에서는 1번, 2번 위치로 가는 길이 길이 이어져 있음
				[1, 0, 1, 1],  # 1번 위치는 모든 곳과 이어져 있음 (자기 자신을 제외한)
				[0, 0, 0, 1],
				[0, 0, 1, 0]]
```

---

## 델타 방향전환과 달팽이 문제 풀이

[SW Expert Academy](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PobmqAPoDFAUq&)

> 방향 전환을 통한 풀이
>

<aside>
💡 아이디어
우-하-좌-상 으로 방향 전환이 고정되어 있다는 점을 활용합니다.

</aside>

```python
# 1954_달팽이숫자

dr = (0, 1, 0, -1)
dc = (1, 0, -1, 0)

for tc in range(1, int(input()) + 1):
    N = int(input())

    snail = [[0] * N for _ in range(N)]
    r, c, d = 0, 0, 0

		# 1부터 N**2까지 차례로 순회하며 할당합니다.
    for num in range(1, N ** 2 + 1):
				# 해당 좌표에 해당 숫자를 할당합니다.
        snail[r][c] = num

				# 기본적으로 기존 방향을 유지하며 다음 좌표를 설정합니다.
        nr, nc = r + dr[d], c + dc[d]

				# 다음 좌표가 범위를 벗어나는 경우 또는 다음 좌표에 이미 숫자가 할당된 경우 방향을 전환합니다.
        if nr < 0 or nr >= N or nc < 0 or nc >= N or snail[nr][nc] != 0:
						# 아래와 같이 방향 전환 좌표를 설정하면 3 => 0으로의 방향 전환이 가능합니다.
            d = (d + 1) % 4
            nr, nc = r + dr[d], c + dc[d]

				# 위에서 계산한 다음 좌표를 현재 좌표로 최신화한 후 다음 반복으로 넘어갑니다.
        r, c = nr, nc

    print(f'#{tc}')
    for ans in snail:
        print(*ans)
```

> 방향 전환 횟수 및 각 방향에서 움직임 횟수에 대한 규칙을 통한 풀이
>

<aside>
💡 아이디어
N자리 달팽이 숫자에서 방향 전환은 (2N-1)번 일어나고,

각 방향에서 움직임 횟수는 N ~ N-1 ~ N-1 ~ N-2 ~ N-2 ~ … ~ 2 ~ 2 ~ 1 ~ 1 순으로 발생한다는 것을 알 수 있습니다.

위와 같은 규칙을 아래 코드를 통해 나타낼 수 있습니다.

</aside>

- Sketch Image
```python
dr = [0, 1, 0, -1]  #우하좌상
dc = [1, 0, -1, 0]

for tc in range(1, int(input())+1):
    N = int(input())
    snail = [[0 for _ in range(N)] for _ in range(N)]

    d = 0  # 방향
    num = 0  # 달팽이 안에 넣을 숫자
    r = 0  # 행 좌표
    c = -1  # 시작 cell은 0이여야하는데, 아래코드로 시작하면 (0, 1)에서 시작. 따라서 (0,0) 옆 왼쪽의 가상의 칸에서 시작한다

    for i in range(N * 2, 1, -1):  # 방향바꾸기 횟수 2N-1
        for _ in range(i // 2):  # 각 방향에서 움직임 횟수
            num += 1
            r += dr[d % 4]
            c += dc[d % 4]
            snail[r][c] = num
        d += 1  # 방향 바꾸기

    print(f'#{tc}')
    for ans in snail:
        print(*ans)
```