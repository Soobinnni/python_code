<aside>
💡 정렬의 종류

</aside>

| 안정 정렬 | 불안정 정렬 |
| --- | --- |
| 버블 정렬 | 선택 정렬 |
| 카운팅 정렬 | 퀵 정렬 |
| 병합 정렬 |  |

## 1️⃣ 버블 정렬 🧼

> 자료를 특정 기준에 의해 작은 값부터 큰 값 혹은 그 반대의 순서로 자리를 바꿔가며 재배열
> 

![Untitled](https://useful-pantry-930.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F310aac07-84bd-4c93-92dd-f77d310a0794%2FUntitled.png?table=block&id=8a59e32d-00e4-4fa5-905a-57d040a77e30&spaceId=2c73f946-8332-4a01-81d0-e72428bf9af8&width=2000&userId=&cache=v2)

![Untitled](https://useful-pantry-930.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2bbf4610-7019-4927-ab3d-51404b107a49%2FUntitled.png?table=block&id=8022742c-c491-422e-8293-d2b2bc053f02&spaceId=2c73f946-8332-4a01-81d0-e72428bf9af8&width=2000&userId=&cache=v2)

![Untitled](https://useful-pantry-930.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2e7dc629-edd5-452c-989e-872d65db9f75%2FUntitled.png?table=block&id=94677572-fd9b-4ad8-b353-45eb6d7f3cde&spaceId=2c73f946-8332-4a01-81d0-e72428bf9af8&width=2000&userId=&cache=v2)

![Untitled](https://useful-pantry-930.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7a963258-2564-4648-bb0b-f5ea565a5017%2FUntitled.png?table=block&id=3a1cf33e-361e-4cc9-81f6-722342a3298d&spaceId=2c73f946-8332-4a01-81d0-e72428bf9af8&width=2000&userId=&cache=v2)

![Untitled](https://useful-pantry-930.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F75fe3ba9-9efa-4a0f-8192-902e2ef11606%2FUntitled.png?table=block&id=2dc668dd-486a-4b07-96c5-17583dd5aad7&spaceId=2c73f946-8332-4a01-81d0-e72428bf9af8&width=2000&userId=&cache=v2)

```python
# 버블 정렬 코드
arr = [2, 4, 1, 3]  # 정렬하고자 하는 리스트의 길이가 4니까?

for i in range(len(arr)-1, 0, -1):  # 총 3회 시행, 
    for j in range(i): # 각 시행 횟수 안에서, 3 2 1 번씩 비교 할것 
        if arr[j] > arr[j+1]: # 내가 오른쪽 녀석보다 크다면?
            arr[j], arr[j+1] = arr[j+1], arr[j]  # 자리를 바꾼다!

print(arr)
```

원본 리스트가 [2, 4, 1, 3]라고 한다면, 해당 리스트를 정렬하려면 다음과 같은 절차를 거칩니다.

우선, **1회**의 시행 안에서 **3번**의 비교를 합니다. 

⇒ 리스트 길이가 4고, 처음은 3번을 비교해야 하니까요!

<첫 번째 시행>

1. `2`와 `4`를 비교한 결과, `2`가 `4`보다 작으므로 위치를 바꾸지 않고 넘어갑니다.
2. `4`와 `1`을 비교한 결과, `4`가 `1`보다 크므로 자리를 바꾸고 [2, 1, 4, 3]이 됩니다.
3. 다시 `4`와 `3`을 비교한 결과, `4`가 `3`보다 크므로 자리를 바꾸고 [2, 1, 3, 4]가 됩니다.

첫 번째 시행의 결과 제일 뒤의 4는 가장 큰 값으로 확정되었습니다. ⇒ [2, 1, 3, **4**]

<두 번째 시행>

 4는 이미 확정이고, 나머지 앞의 3개의 숫자를 비교하기 위해 2번 비교합니다.

[2, 1, 3, **4**] 중 2, 1, 3에 대하여 앞의 논리를 반복합니다.

시행이 거듭될수록 하나씩 하나씩 뒤에 확정된 값이 쌓이게 됩니다.

<aside>
💡 2차원 리스트를 기준점을 잡고 버블 정렬을 할 수 없을까?

</aside>

```python
a = [[4, 4, 16], [6, 1, 6], [4, 3, 12], [1, 12, 12], [5, 4, 20], [2, 3, 6], [3, 4, 12]]

def bubble_sort(idx): # 기준점을 잡고 할 수 있습니다.

    for i in range(len(a)-1, 0, -1):
        for j in range(i):
            if a[j][idx] > a[j+1][idx]: # 기준으로 비교하되,
                a[j], a[j+1] = a[j+1], a[j] # 그 안의 객체가 바뀌는 것!

bubble_sort(1) # 두 번째 인덱스를 기준으로 정렬합니다.

# key를 활용해 다음과 같이 정렬해도 됩니다.
sorted_a = sorted(a, key=lambda x: x[1])
print(sorted_a)
```

---

## 2️⃣ 카운팅 정렬 ⏳

> 주어진 리스트의 `값`의 범위가 작을 때 유용합니다.
> 

⇒ 카드 같은 것들 세기 좋습니다. (범위가 1~ 9인 그런 문제들)

```python
# 카운팅 정렬 코드
nums = [4, 4, 2, 3, 5, 5, 1, 1, 5]

count = [0] * (max(nums) + 1)  # 갯수 세는 리스트
sorted_nums = [0] * len(nums)  # 정렬된 리스트의 원형 틀

for num in nums:  # 일단 몇개씩 있는지 카운트
    count[num] += 1

for i in range(1, len(count)):  # 누적합
    count[i] = count[i] + count[i-1]

for j in range(len(nums)-1, -1, -1):  # 뒤의 자리부터 뽑아서,
    sorted_nums[count[nums[j]]-1] = nums[j] # 5가 튀어나오면 5의 위치에 뒤부터 삽입.
    count[nums[j]] -= 1  # 위치 인덱스 하나 깎음

print(sorted_nums)
```

**아이디어는 다음과 같습니다.**

nums 리스트에서 1이 `두 개`, 2가 `한 개`… 이렇게 하나씩 세서 정리를 할건데,  nums 리스트에서 최댓값을 구해보면 현재는 `5`입니다. 

그러면, 6칸짜리 정리용 리스트만 만들어 두면 nums에서 하나씩 뽑아서 차곡차곡 정리할 수 있습니다.

![Untitled](https://useful-pantry-930.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb7b348ec-b9e1-45cb-a4f8-4adcb519f79e%2FUntitled.png?table=block&id=ee356ea6-c376-4ccd-9f41-032b8cf05171&spaceId=2c73f946-8332-4a01-81d0-e72428bf9af8&width=2000&userId=&cache=v2)

![Untitled](https://useful-pantry-930.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F12912959-cc8a-4fbf-831b-e6740b065601%2FUntitled.png?table=block&id=b8e23b1d-1ab9-452b-aad0-a68eb1ea8b41&spaceId=2c73f946-8332-4a01-81d0-e72428bf9af8&width=2000&userId=&cache=v2)

```python
# 이렇게 만드려고 하는거죠!
# 인덱스 기준으로 1이 두개, 2가 한개, 3이 한개, 4가 두개, 5가 세개
count = [0, 2, 1, 1, 2, 3]

# 그래서 count 기본 틀을 만들 때는 5가 들어가려면 6칸이 필요하므로 1을 더해서 만듭니다.
count = [0] * (max(nums) + 1)
```

<aside>
💡 그러면 누적합은 뭐하러 하는걸까?

</aside>

사실, 아까 count 배열을 차곡차곡 완성했을 때 정렬은 끝나긴 했습니다.

```python
nums = [4, 4, 2, 3, 5, 5, 1, 1, 5]

count = [0] * (max(nums) + 1)

for num in nums: # 차곡차곡
    count[num] += 1

print(count)

sorted_list = []  # 빈 틀

for idx, n in enumerate(count): # 하나씩 뽑으면서
    for _ in range(n):
        sorted_list.append(idx)  # 갯수만큼 순서대로 append!

print(sorted_list) # [1, 1, 2, 3, 4, 4, 5, 5, 5]
```

어차피 인덱스 기준으로 1이 두개, 2가 한개, 3이 한개, 4가 두개, 5가 세개라는걸 알기만 한다면 내가 현재 가지고 있는 `count = [0, 2, 1, 1, 2, 3]` 리스트에서 0은 없으니까 버리고 앞쪽부터 보면서 순서대로 붙인다고 생각해보면,

빈 `sorted_list = [ ]`를 하나 파두고, 1을 두번 append 해서 `sorted_list = [1, 1]`을 만들고 그다음 2를 1번, 3을 1번… 이런식으로 append한 결과는 정렬되어 있을 거니까요!

> 그러면 누적합은 왜 하는데? ⇒ **안정 정렬** 결과를 얻기 위함입니다.
> 

사실, 지금은 원소가 1, 2 같은 숫자니 안 보일지 몰라도 아까 `nums = [4, 4, 2, 3, 5, 5, 1, 1, 5]` 에서 첫 번째 4는 사실 `4-A` 였고, 두 번째 4는 `4-B`라는 다른 존재였다고 생각해보면, 위의 방식으로는 반드시 `4-A`뒤에 `4-B`가 온다고 보장할 수 없습니다.

만약 위의 2차원 버블정렬처럼 리스트의 원소가 (4, ‘A’), (4, ‘b’)였다면 더 확연하게 드러나겠죠.

일단 누적합 결과부터 보면, 다음과 같습니다.

```python
# 원래 숫자들
nums = [4, 4, 2, 3, 5, 5, 1, 1, 5]

# 누적합 전의 카운트 리스트
count = [0, 2, 1, 1, 2, 3]

**# 누적합 결과 => 5번 인덱스의 6은 무슨 의미일까?**
count = [0, 2, 3, 4, 6, 9]

# 빈 틀
sorted_nums = [0, 0, 0, 0, 0, 0, 0, 0, 0]

# 되어야 할 결과 => 실제로 6번에 4라는 숫자가 있다.
sorted_nums = [1, 1, 2, 3, 4, 4, 5, 5, 5]
```

`누적합 결과`의 5번 인덱스의 **`6`**은 무슨 의미냐면,

5번 인덱스, 즉 4라는 숫자는 **되어야 할 결과** 기준으로 **여섯 번째**까지를 **차지해야 한다**는 뜻입니다.

그러니 **안정 정렬**을 위해서는, `원래 숫자들`의 **뒤에서부터 뽑으면서** (이러면 5, 1, 1, 5, … 순으로 나오겠죠?) 차지해야 하는 영역의 오른쪽부터 거꾸로 채워 나가면 됩니다.

곧, `원래 숫자들에서` **5**를 뽑은 후, `누적합 결과`에서 5번째 인덱스를 보니 `9`라는 값이 있고

`9`라는 값은 **5**가 `되어야 할 결과`기준으로 9번째(인덱스로는 8)에 있다는 뜻이니 과정을 살펴보면 

다음과 같습니다.

```python

# 5부터 뽑고, 9번째 위치에(인덱스로는 8이니 -1) 5를 할당
# 이후에 그다음 5는 8번째 위치에 넣어야 하니까 count 배열에서 한 개 깎기
sorted_nums[9 - 1] = 5
count[5] -= 1

# 결과
sorted_nums = [0, 0, 0, 0, 0, 0, 0, 0, 5]
```

 

그런데 이러면 사실 5는 현재 3개가 있으므로 나중에 쓰고나서 깎은 후에는 count 배열의 모습은 다음과 같을 겁니다.

```python
count = [-, -, -, -, -, 6]
```

그런데 저 숫자는 이제 오른쪽 어디에 넣느냐만 나타낼 뿐 6으로 남겨져 있어도 전혀 상관 없습니다.

그래서 뒤에서부터 삽입하는 코드는 다음과 같습니다.

```python
for j in range(len(nums)-1, -1, -1):  # 뒤의 자리부터 뽑아서,
    sorted_nums[count[nums[j]]-1] = nums[j] # 5가 튀어나오면 5의 위치에 뒤부터 삽입.
    count[nums[j]] -= 1  # 위치 인덱스 하나 깎음
```

해당 프로세스를 모두 돌고나면 정렬이 완료됩니다.

---

## 3️⃣ 선택 정렬 ✍️

```python
nums = [10, 15, 2, 19, 6, 14]

for i in range(len(nums)-1):
    min_idx = i  # 일단 가장 작다고 초기화해두고,

    for j in range(i+1, len(nums)): # 나 다음부터 보면서
        if nums[j] < nums[min_idx]:  # 나보다 작은애가 있으면
            min_idx = j  # 그 idx를 갱신!

    nums[i], nums[min_idx] = nums[min_idx], nums[i]  # 최종적으로 한번 스왑

print(nums)
```

> 선택정렬은 왜 불안정 정렬일까??
> 

```python
# 앞의 2는 2-A, 뒤의 2는 2-B라고 생각해보면,
nums = [2, 2, 1, 3]

# 처음 시행의 경우 2-A와 1을 바꾸게 되는 순간 2-B 뒤에 2-A가 오게 되니까!
```

## 4️⃣ 병합 정렬

```python
arr = [6, 3, 7, 2, 5, 8, 11, 13]

def merge_sort(input_list):  # 쪼개는 애

    if len(input_list) == 1:  # 1개 짜리라면 더 쪼갤 필요 없으니까
        return input_list  # 그대로 다시 리턴하기

    mid = len(input_list) // 2  # 기준점이 되는 값 (+1 하면 무한루프)
    left_half = input_list[:mid]  # 여기서 아이디값 분리
    right_half = input_list[mid:]  # 오른쪽 반땡

    left = merge_sort(left_half)  # 분할정복 재귀호출
    right = merge_sort(right_half)

    return merge(left, right)  # 이미 아이디값 분리된 애가 인자로! + 쪼개기가 끝내면 결국 끝은 붙이기 로직!

def merge(left, right):  # 합치는 애
    result = [0]*(len(left)+len(right))  # 들어갈 틀
    l = r = idx = 0  # 포인터 3개는 전부 0으로 초기화

    while l < len(left) and r < len(right):  # 여기 and 여야함!
        if left[l] <= right[r]:  # 얘 덕분에 안정 정렬 가능
            result[idx] = left[l]
            l += 1
            idx += 1
        else:
            result[idx] = right[r]
            r += 1
            idx += 1
    while l < len(left):  # 하나만 돌게될것, 떨거지 처리
        result[idx] = left[l]
        l += 1
        idx += 1
    while r < len(right):
        result[idx] = right[r]
        r += 1
        idx += 1

    return result  # 아이디값 새로 파진걸 리턴해서 안꼬임

print(merge_sort(arr))
# 원본은 안건드림 => id값을 새로 팠으니까
# print(arr)
```

## 5️⃣ 퀵 정렬

`1` 로무토 (맨 오른쪽 피봇)

```python
a = [6, 3, 7, 2, 5, 8, 11, 13]

def lomuto(low, high):
    def partition(low, high):
        pivot = a[high]  # 로무토는 맨 오른쪽을 초기 피봇으로 일단 삼는다
        left = low  # 우선 제일 왼쪽은 low 값으로 초기화 

        for right in range(low, high):  # right => 이동하는 포인터
            if a[right] < pivot:  # 만약 돌아다니면서 피봇보다 작은걸 구한 경우?
                a[left], a[right] = a[right], a[left]  # left,  right 위치 스왑
                left += 1  # 칸막이 한칸 이동

        a[left], a[high] = a[high], a[left]  # 솎아내는거 다 끝나면 칸막이 위치와 맨 오른쪽 피봇값을 스왑

        return left  # 칸막이 인덱스를 뱉음

    if low < high:
        pivot = partition(low, high)  # 뱉어진 칸막이를 기준으로 반땡
        lomuto(low, pivot-1)
        lomuto(pivot+1, high)

lomuto(0, len(a)-1)
print(a)
```

`2` 호어 (중간피봇)

```python
a = [6, 3, 7, 2, 5, 8, 11, 13]

def hoare(low, high):
    def partition(low, high):
        pivot = (low + high) // 2
        L = low
        R = high

        while L < R:
            while a[L] < a[pivot] and L < R:  # 피봇보다 작으면 그다음걸 봐라
                L += 1  # 왼쪽 영역은 피봇보다 큰걸 찾는게 목표니까.
            while a[R] >= a[pivot] and L < R:
                R -= 1
            if L < R:  # 2번 왼쪽에선 피봇보다 큰걸 찾았고 오른쪽에서도 피봇보다 작은걸 적당히 찾은 경우?
                if L == pivot:  # 3번 이건 둘이 완전 쫍아졌을때의 이야기
                    pivot = R
                a[L], a[R] = a[R], a[L]  # 2-1번 그러면 L, R 포인터 위치 스왑 피봇의 왼쪽에서 큰걸 오른쪽으로 토스하고 오른쪽에서 작은걸 왼쪽으로 토스

        a[pivot], a[R] = a[R], a[pivot]  # 1 번 둘이 별탈없이 만나버린 경우라면 피벗과 R 포인터 위치를 교환한다.

        return R

    if low < high:
        pivot = partition(low, high)
        hoare(low, pivot-1)
        hoare(pivot+1, high)

hoare(0, len(a)-1)
print(a)
```