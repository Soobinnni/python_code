## 재귀함수로 부분집합 구하기

```python
arr = ['A', 'B', 'C']  # 재료 리스트
check = [0, 0, 0]  # 위치 체크용 리스트

def powerset(idx):  # 재귀 깊이가 파라미터
    if idx == 3:   # 마지막 깊이에 도달했다면?
        print('체크 배열은 다음과 같음: ', *check)  # 이 당시의 check 배열 현황
        result = []
        for j in range(3):  # 체크 배열을 하나씩 보면서
            if check[j] == 1:  # 살아있다면?
                result.append(arr[j])  # 그 위치를 res에 담음
        print(result)  # res 프린트!
        return

    check[idx] = 0
    powerset(idx + 1)

    check[idx] = 1
    powerset(idx + 1)

    # for i in range(2):
    #     check[idx] = i
    #     powerset(idx+1)

powerset(0)
```

## 순열

`1` 포문순열

```python
arr = ['A', 'B', 'C']

for i in range(3):
    for j in range(3):
        for k in range(3):
            if i != j and j != k and k != i:
								print([arr[i], arr[j], arr[k]])
```

`2` **재귀순열**

```python
arr = ['A', 'B', 'C']  # 재료 리스트
sel = [0, 0, 0]  # 인형뽑기 selection
check = [0, 0, 0]  # 뽑을지 말지 결정하는 리스트

def perm(depth):  # 각자 뎁스에서는? 
    if depth == 3:  # 최고 뎁스에 도달했으면? # if depth == len(sel)
        print(sel)  # print
        return

    for i in range(3):  # 3번의 화살표 떨어트릴 기회
        if not check[i]:  # 각 기회 안에서 check를 보고 멈출 수 있는지 보고?
            check[i] = 1  # 멈출 수 있다면 if 통과했으니까 자리 차지했다고 표시하고
            sel[depth] = arr[i]  # 화살표가 떨어진 위치의 재료리스트
            perm(depth+1)
            check[i] = 0  # 돌아나오면서 다시 다음을 위해 초기화!! (중요)

perm(0)
```

<aside>
💡 중복 순열

</aside>

```python
arr = ['A', 'B', 'C']
sel = [0, 0, 0]

def perm_rep(depth):
    if depth == 3:
        print(*sel)
        return

    for i in range(3):
        sel[depth] = arr[i]
        perm_rep(depth+1)

perm_rep(0)
```

---

## 조합

`1` 포문 조합 

```python
# 그냥 조합 2개뽑기
arr = ['A', 'B', 'C']
for i in range(3):
    for j in range(i+1, 3):
        print(arr[i], arr[j])

# 중복조합 2개뽑기
arr = ['A', 'B', 'C']
for i in range(3):
    for j in range(i, 3):
        print(arr[i], arr[j])
```

`2` 재귀 조합

```python
# 5C3
arr = ['A', 'B', 'C', 'D', 'E']
sel = [0, 0, 0]

def combination(idx, sidx):
    if sidx == 3:  # sel 길이 범위를 벗어나면 sel이 확정됐다는 소리니까 print
        print(sel)
        return

    if idx == 5:  # 얘도 벗어나지 않아야 함
        return

    sel[sidx] = arr[idx]  # sidx가 가리키는 위치에 idx가 가리키는 재료를 넣음
    combination(idx+1, sidx+1)  # 첫번째로는 두개의 화살표가 동시에 오른쪽으로 가보고
    combination(idx+1, sidx)  # 두번째로는 arr 쪽 화살표만 혼자 가봄.

combination(0, 0)
```

<aside>
💡 중복 조합 (재귀)

</aside>

```python
# 좀 더 일반화된 버전
def combi_rep(idx, sidx):
    if sidx == m:
        print(*sel)
        return

    if idx == n:
        return

    sel[sidx] = arr[idx]
    combi_rep(idx, sidx+1)
    combi_rep(idx+1, sidx)

n, m = map(int, input().split())
arr = list(range(1, n+1))
sel = [0]*m
combi_rep(0, 0)
```

<aside>
💡 BOJ N과 M 시리즈로 굳히기

</aside>

[N과 M](https://www.acmicpc.net/workbook/view/2052)

---

## 백트래킹 문제풀이 예시

> 배열최소합
> 

[SW Expert Academy](https://swexpertacademy.com/main/learn/course/subjectDetail.do?courseId=AVuPDN86AAXw5UW6&subjectId=AWOVIc7KqfQDFAWg)

- Answer
    
    ```python
    T = int(input())
    
    for tc in range(1, T+1):
        N = int(input())
        nums = [list(map(int, input().split())) for _ in range(N)]
        answer = 99999999999999999
        check = [0]*N
    
        def perm(depth, acc):
            global answer
    
            if acc >= answer:  # 백트래킹
                return  # 이미 해당 뎁스에서 구해진 최솟값보다 크거나 같으면 의미 x
    
            if depth == N:  # 최후 뎁스 도달 시,
                if answer > acc:
                    answer = acc  # 최솟값 갱신 시도
                return  # 아니라도 일단 리턴
    
            for i in range(N):
                if not check[i]:
                    check[i] = 1
                    perm(depth + 1, acc + nums[depth][i])
                    check[i] = 0
    
        perm(0, 0)
    
        print('#{} {}'.format(tc, answer))
    ```
    

> **N-Queen**
> 

[SW Expert Academy](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV7GKs06AU0DFAXB)

[9663번: N-Queen](https://www.acmicpc.net/problem/9663)

- Answer1 (SWEA)
    
    ```python
    T = int(input())
    
    for tc in range(1, T+1):
        N = int(input())
    
        answer = 0
        visited = [[0] * N for _ in range(N)]
    
        def queens_road(r, c, erase=False):  # 어떤 (r,c) 에서 시작하면 아래, 왼쪽대각선, 오른쪽 대각선을 방문체크 해야함
            # 아래를 방문체크
            for x in range(r, N):
                if not erase:
                    visited[x][c] += 1
                elif erase:  # 지우는 옵션이 True 라면 visited 그 depth 거는 초기화!!
                    visited[x][c] -= 1
    
            # 아래 방향 왼쪽 대각선을 방문체크
            column_left = c
            for y in range(r, N):
                if column_left < 0 or column_left >= N:
                    break
                else:
                    if not erase:
                        visited[y][column_left] += 1
                    elif erase:
                        visited[y][column_left] -= 1
                    column_left -= 1
    
            # 아래 방향 오른쪽 대각선을 방문체크
            column_right = c
            for z in range(r, N):
                if column_right < 0 or column_right >= N:
                    break
                else:
                    if not erase:
                        visited[z][column_right] += 1
                    elif erase:
                        visited[z][column_right] -= 1
                    column_right += 1
    
        def deploy_queens(depth):  # 여기 depth 는 r c 에서의 r 과 같다고 생각
            global answer
    
            if depth == N:  # 이경우는 무사히 퀸들이 배치가 끝나서 최대 뎁스까지 내려간 경우
                answer += 1
                return
    
            else:  # 최대 뎁스까지 도달하지 못한 경우라면?
                for c in range(N):  # 각 뎁스는 N회 만큼 화살표 돌릴 기회를 가질 것.
                    if visited[depth][c] == 0:
                        queens_road(depth, c)  # 아래, 대각선들 다 방문체크 하고
                        deploy_queens(depth + 1)
                        queens_road(depth, c, erase=True)  # depth 빠져나오면 방문 초기화.
    
        deploy_queens(0)  # 맨 위부터 시작해야함
        print('#{} {}'.format(tc, answer))
    ```
    
- Answer2 (SWEA)
    
    ```python
    T = int(input())
    
    for tc in range(1, T+1):
        N = int(input())
        arr = [0] * N
        answer = 0
    
        def deploy_queens(current_depth):
            global answer
            if current_depth == N:
                answer += 1
                return
    
            for i in range(N):
                arr[current_depth] = i
                for check_depth in range(current_depth):
                    if arr[check_depth] == arr[current_depth]:  # 열 검사부터
                        break
                    if (current_depth - check_depth) == abs(arr[current_depth] - arr[check_depth]):  # 대각선 검사
                        break
                else:
                    deploy_queens(current_depth+1)
    
        deploy_queens(0)
        print('#{} {}'.format(tc, answer))
    ```
    
- Answer3(BOJ)
    ```python
    import sys
    input = sys.stdin.readline
    
    N = int(input())
    ans = 0
    
    check_vertical = [False] * N                            # 상하 체크
    check_diagonal_left = [False] * (2 * N - 1)             # 왼쪽 대각선 체크
    check_diagonal_right = [False] * (2 * N - 1)            # 오른쪽 대각선 체크
    
    def n_queen(depth):
        global ans
    
        if depth == N:                                      # 기저 사례: depth가 N까지 도달하면 성공!
            ans += 1                                        # 정답에 1 추가하고 리턴
            return
    
        for i in range(N):                                  # 해당 depth에서 하나씩 둬보며
            if check_vertical[i] or check_diagonal_left[depth - i] or check_diagonal_right[depth + i]:
                continue                                    # 상하 or 왼쪽 대각선 or 오른쪽 대각선에 퀸이 있다면 패스
    
            check_vertical[i] = True                        # 없다면 각각 체크하고
            check_diagonal_left[depth - i] = True
            check_diagonal_right[depth + i] = True
    
            n_queen(depth + 1)                              # 다음 depth로 이동
    
            check_vertical[i] = False                       # depth에서 나올 때 체크 풀어주기(중요)
            check_diagonal_left[depth - i] = False
            check_diagonal_right[depth + i] = False
    
    n_queen(0)                                              # 항상 0번 depth에서 시작
    
    print(ans)
    ```