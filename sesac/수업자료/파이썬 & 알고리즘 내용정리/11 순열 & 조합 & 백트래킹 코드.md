## ì¬ê·€í•¨ìˆ˜ë¡œ ë¶€ë¶„ì§‘í•© êµ¬í•˜ê¸°

```python
arr = ['A', 'B', 'C']  # ì¬ë£Œ ë¦¬ìŠ¤íŠ¸
check = [0, 0, 0]  # ìœ„ì¹˜ ì²´í¬ìš© ë¦¬ìŠ¤íŠ¸

def powerset(idx):  # ì¬ê·€ ê¹Šì´ê°€ íŒŒë¼ë¯¸í„°
    if idx == 3:   # ë§ˆì§€ë§‰ ê¹Šì´ì— ë„ë‹¬í–ˆë‹¤ë©´?
        print('ì²´í¬ ë°°ì—´ì€ ë‹¤ìŒê³¼ ê°™ìŒ: ', *check)  # ì´ ë‹¹ì‹œì˜ check ë°°ì—´ í˜„í™©
        result = []
        for j in range(3):  # ì²´í¬ ë°°ì—´ì„ í•˜ë‚˜ì”© ë³´ë©´ì„œ
            if check[j] == 1:  # ì‚´ì•„ìˆë‹¤ë©´?
                result.append(arr[j])  # ê·¸ ìœ„ì¹˜ë¥¼ resì— ë‹´ìŒ
        print(result)  # res í”„ë¦°íŠ¸!
        return

    check[idx] = 0
    powerset(idx + 1)

    check[idx] = 1
    powerset(idx + 1)

    # for i in range(2):
    #     check[idx] = i
    #     powerset(idx+1)

powerset(0)
```

## ìˆœì—´

`1` í¬ë¬¸ìˆœì—´

```python
arr = ['A', 'B', 'C']

for i in range(3):
    for j in range(3):
        for k in range(3):
            if i != j and j != k and k != i:
								print([arr[i], arr[j], arr[k]])
```

`2` **ì¬ê·€ìˆœì—´**

```python
arr = ['A', 'B', 'C']  # ì¬ë£Œ ë¦¬ìŠ¤íŠ¸
sel = [0, 0, 0]  # ì¸í˜•ë½‘ê¸° selection
check = [0, 0, 0]  # ë½‘ì„ì§€ ë§ì§€ ê²°ì •í•˜ëŠ” ë¦¬ìŠ¤íŠ¸

def perm(depth):  # ê°ì ëìŠ¤ì—ì„œëŠ”? 
    if depth == 3:  # ìµœê³  ëìŠ¤ì— ë„ë‹¬í–ˆìœ¼ë©´? # if depth == len(sel)
        print(sel)  # print
        return

    for i in range(3):  # 3ë²ˆì˜ í™”ì‚´í‘œ ë–¨ì–´íŠ¸ë¦´ ê¸°íšŒ
        if not check[i]:  # ê° ê¸°íšŒ ì•ˆì—ì„œ checkë¥¼ ë³´ê³  ë©ˆì¶œ ìˆ˜ ìˆëŠ”ì§€ ë³´ê³ ?
            check[i] = 1  # ë©ˆì¶œ ìˆ˜ ìˆë‹¤ë©´ if í†µê³¼í–ˆìœ¼ë‹ˆê¹Œ ìë¦¬ ì°¨ì§€í–ˆë‹¤ê³  í‘œì‹œí•˜ê³ 
            sel[depth] = arr[i]  # í™”ì‚´í‘œê°€ ë–¨ì–´ì§„ ìœ„ì¹˜ì˜ ì¬ë£Œë¦¬ìŠ¤íŠ¸
            perm(depth+1)
            check[i] = 0  # ëŒì•„ë‚˜ì˜¤ë©´ì„œ ë‹¤ì‹œ ë‹¤ìŒì„ ìœ„í•´ ì´ˆê¸°í™”!! (ì¤‘ìš”)

perm(0)
```

<aside>
ğŸ’¡ ì¤‘ë³µ ìˆœì—´

</aside>

```python
arr = ['A', 'B', 'C']
sel = [0, 0, 0]

def perm_rep(depth):
    if depth == 3:
        print(*sel)
        return

    for i in range(3):
        sel[depth] = arr[i]
        perm_rep(depth+1)

perm_rep(0)
```

---

## ì¡°í•©

`1` í¬ë¬¸ ì¡°í•© 

```python
# ê·¸ëƒ¥ ì¡°í•© 2ê°œë½‘ê¸°
arr = ['A', 'B', 'C']
for i in range(3):
    for j in range(i+1, 3):
        print(arr[i], arr[j])

# ì¤‘ë³µì¡°í•© 2ê°œë½‘ê¸°
arr = ['A', 'B', 'C']
for i in range(3):
    for j in range(i, 3):
        print(arr[i], arr[j])
```

`2` ì¬ê·€ ì¡°í•©

```python
# 5C3
arr = ['A', 'B', 'C', 'D', 'E']
sel = [0, 0, 0]

def combination(idx, sidx):
    if sidx == 3:  # sel ê¸¸ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ selì´ í™•ì •ëë‹¤ëŠ” ì†Œë¦¬ë‹ˆê¹Œ print
        print(sel)
        return

    if idx == 5:  # ì–˜ë„ ë²—ì–´ë‚˜ì§€ ì•Šì•„ì•¼ í•¨
        return

    sel[sidx] = arr[idx]  # sidxê°€ ê°€ë¦¬í‚¤ëŠ” ìœ„ì¹˜ì— idxê°€ ê°€ë¦¬í‚¤ëŠ” ì¬ë£Œë¥¼ ë„£ìŒ
    combination(idx+1, sidx+1)  # ì²«ë²ˆì§¸ë¡œëŠ” ë‘ê°œì˜ í™”ì‚´í‘œê°€ ë™ì‹œì— ì˜¤ë¥¸ìª½ìœ¼ë¡œ ê°€ë³´ê³ 
    combination(idx+1, sidx)  # ë‘ë²ˆì§¸ë¡œëŠ” arr ìª½ í™”ì‚´í‘œë§Œ í˜¼ì ê°€ë´„.

combination(0, 0)
```

<aside>
ğŸ’¡ ì¤‘ë³µ ì¡°í•© (ì¬ê·€)

</aside>

```python
# ì¢€ ë” ì¼ë°˜í™”ëœ ë²„ì „
def combi_rep(idx, sidx):
    if sidx == m:
        print(*sel)
        return

    if idx == n:
        return

    sel[sidx] = arr[idx]
    combi_rep(idx, sidx+1)
    combi_rep(idx+1, sidx)

n, m = map(int, input().split())
arr = list(range(1, n+1))
sel = [0]*m
combi_rep(0, 0)
```

<aside>
ğŸ’¡ BOJ Nê³¼ M ì‹œë¦¬ì¦ˆë¡œ êµ³íˆê¸°

</aside>

[Nê³¼ M](https://www.acmicpc.net/workbook/view/2052)

---

## ë°±íŠ¸ë˜í‚¹ ë¬¸ì œí’€ì´ ì˜ˆì‹œ

> ë°°ì—´ìµœì†Œí•©
> 

[SW Expert Academy](https://swexpertacademy.com/main/learn/course/subjectDetail.do?courseId=AVuPDN86AAXw5UW6&subjectId=AWOVIc7KqfQDFAWg)

- Answer
    
    ```python
    T = int(input())
    
    for tc in range(1, T+1):
        N = int(input())
        nums = [list(map(int, input().split())) for _ in range(N)]
        answer = 99999999999999999
        check = [0]*N
    
        def perm(depth, acc):
            global answer
    
            if acc >= answer:  # ë°±íŠ¸ë˜í‚¹
                return  # ì´ë¯¸ í•´ë‹¹ ëìŠ¤ì—ì„œ êµ¬í•´ì§„ ìµœì†Ÿê°’ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ìœ¼ë©´ ì˜ë¯¸ x
    
            if depth == N:  # ìµœí›„ ëìŠ¤ ë„ë‹¬ ì‹œ,
                if answer > acc:
                    answer = acc  # ìµœì†Ÿê°’ ê°±ì‹  ì‹œë„
                return  # ì•„ë‹ˆë¼ë„ ì¼ë‹¨ ë¦¬í„´
    
            for i in range(N):
                if not check[i]:
                    check[i] = 1
                    perm(depth + 1, acc + nums[depth][i])
                    check[i] = 0
    
        perm(0, 0)
    
        print('#{} {}'.format(tc, answer))
    ```
    

> **N-Queen**
> 

[SW Expert Academy](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV7GKs06AU0DFAXB)

[9663ë²ˆ: N-Queen](https://www.acmicpc.net/problem/9663)

- Answer1 (SWEA)
    
    ```python
    T = int(input())
    
    for tc in range(1, T+1):
        N = int(input())
    
        answer = 0
        visited = [[0] * N for _ in range(N)]
    
        def queens_road(r, c, erase=False):  # ì–´ë–¤ (r,c) ì—ì„œ ì‹œì‘í•˜ë©´ ì•„ë˜, ì™¼ìª½ëŒ€ê°ì„ , ì˜¤ë¥¸ìª½ ëŒ€ê°ì„ ì„ ë°©ë¬¸ì²´í¬ í•´ì•¼í•¨
            # ì•„ë˜ë¥¼ ë°©ë¬¸ì²´í¬
            for x in range(r, N):
                if not erase:
                    visited[x][c] += 1
                elif erase:  # ì§€ìš°ëŠ” ì˜µì…˜ì´ True ë¼ë©´ visited ê·¸ depth ê±°ëŠ” ì´ˆê¸°í™”!!
                    visited[x][c] -= 1
    
            # ì•„ë˜ ë°©í–¥ ì™¼ìª½ ëŒ€ê°ì„ ì„ ë°©ë¬¸ì²´í¬
            column_left = c
            for y in range(r, N):
                if column_left < 0 or column_left >= N:
                    break
                else:
                    if not erase:
                        visited[y][column_left] += 1
                    elif erase:
                        visited[y][column_left] -= 1
                    column_left -= 1
    
            # ì•„ë˜ ë°©í–¥ ì˜¤ë¥¸ìª½ ëŒ€ê°ì„ ì„ ë°©ë¬¸ì²´í¬
            column_right = c
            for z in range(r, N):
                if column_right < 0 or column_right >= N:
                    break
                else:
                    if not erase:
                        visited[z][column_right] += 1
                    elif erase:
                        visited[z][column_right] -= 1
                    column_right += 1
    
        def deploy_queens(depth):  # ì—¬ê¸° depth ëŠ” r c ì—ì„œì˜ r ê³¼ ê°™ë‹¤ê³  ìƒê°
            global answer
    
            if depth == N:  # ì´ê²½ìš°ëŠ” ë¬´ì‚¬íˆ í€¸ë“¤ì´ ë°°ì¹˜ê°€ ëë‚˜ì„œ ìµœëŒ€ ëìŠ¤ê¹Œì§€ ë‚´ë ¤ê°„ ê²½ìš°
                answer += 1
                return
    
            else:  # ìµœëŒ€ ëìŠ¤ê¹Œì§€ ë„ë‹¬í•˜ì§€ ëª»í•œ ê²½ìš°ë¼ë©´?
                for c in range(N):  # ê° ëìŠ¤ëŠ” NíšŒ ë§Œí¼ í™”ì‚´í‘œ ëŒë¦´ ê¸°íšŒë¥¼ ê°€ì§ˆ ê²ƒ.
                    if visited[depth][c] == 0:
                        queens_road(depth, c)  # ì•„ë˜, ëŒ€ê°ì„ ë“¤ ë‹¤ ë°©ë¬¸ì²´í¬ í•˜ê³ 
                        deploy_queens(depth + 1)
                        queens_road(depth, c, erase=True)  # depth ë¹ ì ¸ë‚˜ì˜¤ë©´ ë°©ë¬¸ ì´ˆê¸°í™”.
    
        deploy_queens(0)  # ë§¨ ìœ„ë¶€í„° ì‹œì‘í•´ì•¼í•¨
        print('#{} {}'.format(tc, answer))
    ```
    
- Answer2 (SWEA)
    
    ```python
    T = int(input())
    
    for tc in range(1, T+1):
        N = int(input())
        arr = [0] * N
        answer = 0
    
        def deploy_queens(current_depth):
            global answer
            if current_depth == N:
                answer += 1
                return
    
            for i in range(N):
                arr[current_depth] = i
                for check_depth in range(current_depth):
                    if arr[check_depth] == arr[current_depth]:  # ì—´ ê²€ì‚¬ë¶€í„°
                        break
                    if (current_depth - check_depth) == abs(arr[current_depth] - arr[check_depth]):  # ëŒ€ê°ì„  ê²€ì‚¬
                        break
                else:
                    deploy_queens(current_depth+1)
    
        deploy_queens(0)
        print('#{} {}'.format(tc, answer))
    ```
    
- Answer3(BOJ)
    ```python
    import sys
    input = sys.stdin.readline
    
    N = int(input())
    ans = 0
    
    check_vertical = [False] * N                            # ìƒí•˜ ì²´í¬
    check_diagonal_left = [False] * (2 * N - 1)             # ì™¼ìª½ ëŒ€ê°ì„  ì²´í¬
    check_diagonal_right = [False] * (2 * N - 1)            # ì˜¤ë¥¸ìª½ ëŒ€ê°ì„  ì²´í¬
    
    def n_queen(depth):
        global ans
    
        if depth == N:                                      # ê¸°ì € ì‚¬ë¡€: depthê°€ Nê¹Œì§€ ë„ë‹¬í•˜ë©´ ì„±ê³µ!
            ans += 1                                        # ì •ë‹µì— 1 ì¶”ê°€í•˜ê³  ë¦¬í„´
            return
    
        for i in range(N):                                  # í•´ë‹¹ depthì—ì„œ í•˜ë‚˜ì”© ë‘¬ë³´ë©°
            if check_vertical[i] or check_diagonal_left[depth - i] or check_diagonal_right[depth + i]:
                continue                                    # ìƒí•˜ or ì™¼ìª½ ëŒ€ê°ì„  or ì˜¤ë¥¸ìª½ ëŒ€ê°ì„ ì— í€¸ì´ ìˆë‹¤ë©´ íŒ¨ìŠ¤
    
            check_vertical[i] = True                        # ì—†ë‹¤ë©´ ê°ê° ì²´í¬í•˜ê³ 
            check_diagonal_left[depth - i] = True
            check_diagonal_right[depth + i] = True
    
            n_queen(depth + 1)                              # ë‹¤ìŒ depthë¡œ ì´ë™
    
            check_vertical[i] = False                       # depthì—ì„œ ë‚˜ì˜¬ ë•Œ ì²´í¬ í’€ì–´ì£¼ê¸°(ì¤‘ìš”)
            check_diagonal_left[depth - i] = False
            check_diagonal_right[depth + i] = False
    
    n_queen(0)                                              # í•­ìƒ 0ë²ˆ depthì—ì„œ ì‹œì‘
    
    print(ans)
    ```